"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transformer = void 0;
var dayjs = require("dayjs");
var customParseFormat = require("dayjs/plugin/customParseFormat");
var isSameOrBefore = require("dayjs/plugin/isSameOrBefore");
var isSameOrAfter = require("dayjs/plugin/isSameOrAfter");
var isBetween = require("dayjs/plugin/isBetween");
var Models_1 = require("./Models");
var utils_1 = require("./utils");
dayjs.extend(customParseFormat);
dayjs.extend(isSameOrBefore);
dayjs.extend(isSameOrAfter);
var areDatesEqual = function (column, date1, date2) {
    switch (column.dataType) {
        case Models_1.ColumnDataType.Date:
            return dayjs(date1, column.dateOriginFormat).isSame(dayjs(date2, column.dateOriginFormat), 'd');
        case Models_1.ColumnDataType.DateTime:
        case Models_1.ColumnDataType.DateTimeUtc:
            return dayjs(date1, column.dateOriginFormat).isSame(dayjs(date2, column.dateOriginFormat), 'd');
    }
};
var isDateAfter = function (column, date1, date2, inclusive) {
    if (inclusive === void 0) { inclusive = false; }
    if (inclusive) {
        return dayjs(date1, column.dateOriginFormat).isSameOrAfter(dayjs(date2, column.dateOriginFormat), 'd');
    }
    return dayjs(date1, column.dateOriginFormat).isAfter(dayjs(date2, column.dateOriginFormat), 'd');
};
var isDateBefore = function (column, date1, date2, inclusive) {
    if (inclusive === void 0) { inclusive = false; }
    if (inclusive) {
        return dayjs(date1, column.dateOriginFormat).isSameOrBefore(dayjs(date2, column.dateOriginFormat), 'd');
    }
    return dayjs(date1, column.dateOriginFormat).isBefore(dayjs(date2, column.dateOriginFormat), 'd');
};
var dateIsBetween = function (column, from, to, value) {
    dayjs.extend(isBetween);
    return dayjs(dayjs(value, column.dateOriginFormat)).isBetween(dayjs(from, column.dateOriginFormat), dayjs(to, column.dateOriginFormat), null, '[]');
};
var Transformer = /** @class */ (function () {
    function Transformer() {
    }
    Transformer.getResponse = function (request, dataSource) {
        var response = new Models_1.GridResponse(request.counter);
        response.totalRecordCount = dataSource.length;
        var data = this.applyFreeTextSearch(request, dataSource);
        data = this.applyFiltering(request, data);
        data = this.applySorting(request, data);
        response.filteredRecordCount = data.length;
        if (request.take > -1) {
            response.totalPages = Math.ceil(response.filteredRecordCount / request.take);
            if (response.totalPages > 0) {
                response.currentPage = request.skip / request.take + 1;
            }
        }
        response.aggregationPayload = this.getAggregatePayload(request, data);
        response.payload = data
            .slice(request.skip, request.skip + request.take)
            .map(function (row) { return utils_1.parsePayload(row, request.columns); });
        return response;
    };
    Transformer.applyFreeTextSearch = function (request, subset) {
        if (!!request.searchText) {
            var searchableColumns_1 = request.columns.filter(function (x) { return x.searchable; });
            if (searchableColumns_1.length > 0) {
                var filter_1 = request.searchText.toLowerCase();
                if (filter_1 === '') {
                    return subset;
                }
                return subset.filter(function (item) {
                    return searchableColumns_1.some(function (x) {
                        if (typeof item[x.name] === 'undefined') {
                            return false;
                        }
                        else {
                            return item[x.name].toLowerCase().indexOf(filter_1) > -1;
                        }
                    });
                });
            }
        }
        return subset;
    };
    Transformer.applyFiltering = function (request, subset) {
        request.columns
            .filter(function (column) { return Models_1.columnHasFilter(column); })
            .forEach(function (column) {
            var isDate = column.dataType === Models_1.ColumnDataType.Date ||
                column.dataType === Models_1.ColumnDataType.DateTime ||
                column.dataType === Models_1.ColumnDataType.DateTimeUtc;
            var partialfiltering = function (data, action) {
                return data.filter(function (row) {
                    return typeof row[column.name] === 'undefined' || row[column.name] === null
                        ? false
                        : action(row[column.name]);
                });
            };
            switch (column.filterOperator) {
                case Models_1.CompareOperators.Equals:
                    if (isDate) {
                        subset = subset.filter(function (row) { return areDatesEqual(column, row[column.name], column.filterText); });
                    }
                    else if (column.dataType === Models_1.ColumnDataType.String) {
                        subset = partialfiltering(subset, function (x) { return x.toLowerCase() === column.filterText.toLowerCase(); });
                    }
                    else {
                        subset = subset.filter(function (row) { return row[column.name] === column.filterText; });
                    }
                    break;
                case Models_1.CompareOperators.NotEquals:
                    if (column.dataType === 'string') {
                        subset = partialfiltering(subset, function (x) { return x.toLowerCase() !== column.filterText.toLowerCase(); });
                    }
                    else {
                        subset = subset.filter(function (row) { return row[column.name] !== column.filterText; });
                    }
                    break;
                case Models_1.CompareOperators.Contains:
                    subset = partialfiltering(subset, function (x) { return x.toLowerCase().indexOf(column.filterText.toLowerCase()) >= 0; });
                    subset = partialfiltering(subset, function (x) { return x.toLowerCase().indexOf(column.filterText.toLowerCase()) >= 0; });
                    break;
                case Models_1.CompareOperators.NotContains:
                    subset = partialfiltering(subset, function (x) { return x.toLowerCase().indexOf(column.filterText.toLowerCase()) < 0; });
                    break;
                case Models_1.CompareOperators.StartsWith:
                    subset = partialfiltering(subset, function (x) {
                        return x.toLowerCase().startsWith(column.filterText.toLowerCase());
                    });
                    break;
                case Models_1.CompareOperators.NotStartsWith:
                    subset = partialfiltering(subset, function (x) { return !x.toLowerCase().startsWith(column.filterText.toLowerCase()); });
                    break;
                case Models_1.CompareOperators.EndsWith:
                    subset = partialfiltering(subset, function (x) {
                        return x.toLowerCase().endsWith(column.filterText.toLowerCase());
                    });
                case Models_1.CompareOperators.NotEndsWith:
                    subset = partialfiltering(subset, function (x) { return !x.toLowerCase().endsWith(column.filterText.toLowerCase()); });
                    break;
                case Models_1.CompareOperators.Gt:
                    if (isDate) {
                        subset = subset.filter(function (row) { return isDateAfter(column, row[column.name], column.filterText); });
                    }
                    else {
                        subset = subset.filter(function (row) { return row[column.name] > column.filterText; });
                    }
                    break;
                case Models_1.CompareOperators.Gte:
                    if (isDate) {
                        subset = subset.filter(function (row) {
                            return isDateAfter(column, row[column.name], column.filterText, true);
                        });
                    }
                    else {
                        subset = subset.filter(function (row) { return row[column.name] >= column.filterText; });
                    }
                    break;
                case Models_1.CompareOperators.Lt:
                    if (isDate) {
                        subset = subset.filter(function (row) { return isDateBefore(column, row[column.name], column.filterText); });
                    }
                    else {
                        subset = subset.filter(function (row) { return row[column.name] < column.filterText; });
                    }
                    break;
                case Models_1.CompareOperators.Lte:
                    if (isDate) {
                        subset = subset.filter(function (row) {
                            return isDateBefore(column, row[column.name], column.filterText, true);
                        });
                    }
                    else {
                        subset = subset.filter(function (row) { return row[column.name] <= column.filterText; });
                    }
                    break;
                case Models_1.CompareOperators.Between:
                    if (isDate) {
                        subset = subset.filter(function (row) {
                            return dateIsBetween(column, column.filterText, column.filterArgument[0].toString(), row[column.name]);
                        });
                    }
                    else {
                        subset = subset.filter(function (row) {
                            return row[column.name] >= column.filterText &&
                                row[column.name] <= column.filterArgument[0];
                        });
                    }
                    break;
                default:
                    throw new Error('Unsupported Compare Operator');
            }
        });
        return subset;
    };
    Transformer.applySorting = function (request, subset) {
        var sortedColumns = request.columns.filter(function (column) { return column.sortOrder > 0; });
        var sorts = [{ name: request.columns[0].name, asc: true }];
        if (sortedColumns.length > 0) {
            sortedColumns.sort(function (a, b) { return (a.sortOrder > b.sortOrder ? 1 : b.sortOrder > a.sortOrder ? -1 : 0); });
            sorts = sortedColumns.map(function (y) { return ({
                name: y.name,
                asc: y.sortDirection === Models_1.ColumnSortDirection.Ascending,
            }); });
        }
        subset.sort(function (a, b) {
            var result = 0;
            for (var _i = 0, sorts_1 = sorts; _i < sorts_1.length; _i++) {
                var current = sorts_1[_i];
                var reverse = current.asc ? 1 : -1;
                if (typeof a[current.name] === 'undefined' || typeof b[current.name] === 'undefined') {
                    result = reverse * -1;
                    break;
                }
                if (a[current.name] < b[current.name]) {
                    result = reverse * -1;
                    break;
                }
                if (a[current.name] > b[current.name]) {
                    result = reverse * 1;
                    break;
                }
            }
            return result;
        });
        return subset;
    };
    Transformer.getAggregatePayload = function (request, subset) {
        var aggregateColumns = request.columns.filter(function (column) {
            return column.aggregate && column.aggregate.toLowerCase() !== Models_1.AggregateFunctions.None.toLowerCase();
        });
        return aggregateColumns.reduce(function (prev, column) {
            switch (column.aggregate.toLowerCase()) {
                case Models_1.AggregateFunctions.Sum.toLowerCase():
                    prev[column.name] =
                        subset.length === 0
                            ? 0
                            : subset.reduce(function (sum, r) { return (typeof r[column.name] === 'undefined' ? sum : sum + r[column.name]); }, 0);
                    break;
                case Models_1.AggregateFunctions.Average.toLowerCase():
                    prev[column.name] =
                        subset.length === 0
                            ? 0
                            : subset.reduce(function (sum, r) { return (typeof r[column.name] === 'undefined' ? sum : sum + r[column.name]); }, 0) / subset.length;
                    break;
                case Models_1.AggregateFunctions.Max.toLowerCase():
                    prev[column.name] =
                        subset.length === 0
                            ? 0
                            : subset.reduce(function (max, r) { return (r[column.name] > max ? r[column.name] : max); }, subset[0][column.name]);
                    break;
                case Models_1.AggregateFunctions.Min.toLowerCase():
                    prev[column.name] =
                        subset.length === 0
                            ? 0
                            : subset.reduce(function (min, r) { return (r[column.name] < min ? r[column.name] : min); }, subset[0][column.name]);
                    break;
                case Models_1.AggregateFunctions.Count.toLowerCase():
                    prev[column.name] = subset.length;
                    break;
                case Models_1.AggregateFunctions.DistinctCount.toLowerCase():
                    prev[column.name] =
                        subset.length === 0
                            ? 0
                            : subset.reduce(function (list, r) {
                                if (list.indexOf(r[column.name]) === -1) {
                                    list.push(r[column.name]);
                                }
                                return list;
                            }, []).length;
                    break;
                default:
                    throw new Error('Unsupported aggregate function');
            }
            return prev;
        }, {});
    };
    return Transformer;
}());
exports.Transformer = Transformer;
