{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.getStyledEvents = undefined;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _sortBy = require('lodash/sortBy');\n\nvar _sortBy2 = _interopRequireDefault(_sortBy);\n\nvar _accessors = require('./accessors');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar Event = function () {\n  function Event(data, _ref) {\n    var startAccessor = _ref.startAccessor,\n        endAccessor = _ref.endAccessor,\n        slotMetrics = _ref.slotMetrics;\n\n    _classCallCheck(this, Event);\n\n    var _slotMetrics$getRange = slotMetrics.getRange((0, _accessors.accessor)(data, startAccessor), (0, _accessors.accessor)(data, endAccessor)),\n        start = _slotMetrics$getRange.start,\n        startDate = _slotMetrics$getRange.startDate,\n        end = _slotMetrics$getRange.end,\n        endDate = _slotMetrics$getRange.endDate,\n        top = _slotMetrics$getRange.top,\n        height = _slotMetrics$getRange.height;\n\n    this.start = start;\n    this.end = end;\n    this.startMs = +startDate;\n    this.endMs = +endDate;\n    this.top = top;\n    this.height = height;\n    this.data = data;\n  }\n  /**\n   * The event's width without any overlap.\n   */\n\n\n  _createClass(Event, [{\n    key: '_width',\n    get: function get() {\n      // The container event's width is determined by the maximum number of\n      // events in any of its rows.\n      if (this.rows) {\n        var columns = this.rows.reduce(function (max, row) {\n          return Math.max(max, row.leaves.length + 1);\n        }, // add itself\n        0) + 1; // add the container\n\n        return 100 / columns;\n      }\n\n      var availableWidth = 100 - this.container._width; // The row event's width is the space left by the container, divided\n      // among itself and its leaves.\n\n      if (this.leaves) {\n        return availableWidth / (this.leaves.length + 1);\n      } // The leaf event's width is determined by its row's width\n\n\n      return this.row._width;\n    }\n    /**\n     * The event's calculated width, possibly with extra width added for\n     * overlapping effect.\n     */\n\n  }, {\n    key: 'width',\n    get: function get() {\n      var noOverlap = this._width;\n      var overlap = Math.min(100, this._width * 1.7); // Containers can always grow.\n\n      if (this.rows) {\n        return overlap;\n      } // Rows can grow if they have leaves.\n\n\n      if (this.leaves) {\n        return this.leaves.length > 0 ? overlap : noOverlap;\n      } // Leaves can grow unless they're the last item in a row.\n\n\n      var leaves = this.row.leaves;\n      var index = leaves.indexOf(this);\n      return index === leaves.length - 1 ? noOverlap : overlap;\n    }\n  }, {\n    key: 'xOffset',\n    get: function get() {\n      // Containers have no offset.\n      if (this.rows) return 0; // Rows always start where their container ends.\n\n      if (this.leaves) return this.container._width; // Leaves are spread out evenly on the space left by its row.\n\n      var _row = this.row,\n          leaves = _row.leaves,\n          xOffset = _row.xOffset,\n          _width = _row._width;\n      var index = leaves.indexOf(this) + 1;\n      return xOffset + index * _width;\n    }\n  }]);\n\n  return Event;\n}();\n/**\n * Return true if event a and b is considered to be on the same row.\n */\n\n\nfunction onSameRow(a, b) {\n  return (// Occupies the same start slot.\n    Math.abs(b.start - a.start) <= 30 || // A's start slot overlaps with b's end slot.\n    a.start > b.start && a.start < b.end\n  );\n}\n\nfunction sortByRender(events) {\n  var sortedByTime = (0, _sortBy2.default)(events, ['startMs', function (e) {\n    return -e.endMs;\n  }]);\n  var sorted = [];\n\n  while (sortedByTime.length > 0) {\n    var event = sortedByTime.shift();\n    sorted.push(event);\n\n    for (var i = 0; i < sortedByTime.length; i++) {\n      var test = sortedByTime[i]; // Still inside this event, look for next.\n\n      if (event.endMs > test.startMs) continue; // We've found the first event of the next event group.\n      // If that event is not right next to our current event, we have to\n      // move it here.\n\n      if (i > 0) {\n        var _event = sortedByTime.splice(i, 1)[0];\n        sorted.push(_event);\n      } // We've already found the next event group, so stop looking.\n\n\n      break;\n    }\n  }\n\n  return sorted;\n}\n\nfunction getStyledEvents(_ref2) {\n  var events = _ref2.events,\n      props = _objectWithoutProperties(_ref2, ['events']); // Create proxy events and order them so that we don't have\n  // to fiddle with z-indexes.\n\n\n  var proxies = events.map(function (event) {\n    return new Event(event, props);\n  });\n  var eventsInRenderOrder = sortByRender(proxies); // Group overlapping events, while keeping order.\n  // Every event is always one of: container, row or leaf.\n  // Containers can contain rows, and rows can contain leaves.\n\n  var containerEvents = [];\n\n  var _loop = function _loop(i) {\n    var event = eventsInRenderOrder[i]; // Check if this event can go into a container event.\n\n    var container = containerEvents.find(function (c) {\n      return c.end > event.start || Math.abs(event.start - c.start) < 30;\n    }); // Couldn't find a container — that means this event is a container.\n\n    if (!container) {\n      event.rows = [];\n      containerEvents.push(event);\n      return 'continue';\n    } // Found a container for the event.\n\n\n    event.container = container; // Check if the event can be placed in an existing row.\n    // Start looking from behind.\n\n    var row = null;\n\n    for (var j = container.rows.length - 1; !row && j >= 0; j--) {\n      if (onSameRow(container.rows[j], event)) {\n        row = container.rows[j];\n      }\n    }\n\n    if (row) {\n      // Found a row, so add it.\n      row.leaves.push(event);\n      event.row = row;\n    } else {\n      // Couldn't find a row – that means this event is a row.\n      event.leaves = [];\n      container.rows.push(event);\n    }\n  };\n\n  for (var i = 0; i < eventsInRenderOrder.length; i++) {\n    var _ret = _loop(i);\n\n    if (_ret === 'continue') continue;\n  } // Return the original events, along with their styles.\n\n\n  return eventsInRenderOrder.map(function (event) {\n    return {\n      event: event.data,\n      style: {\n        top: event.top,\n        height: event.height,\n        width: event.width,\n        xOffset: event.xOffset\n      }\n    };\n  });\n}\n\nexports.getStyledEvents = getStyledEvents;","map":{"version":3,"sources":["/Users/leonardogutierrezjuarez/Documents/GitHub/Front-Podologo/node_modules/react-big-calendar/lib/utils/DayEventLayout.js"],"names":["exports","__esModule","getStyledEvents","undefined","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","prototype","_sortBy","require","_sortBy2","_interopRequireDefault","_accessors","obj","default","_objectWithoutProperties","keys","indexOf","hasOwnProperty","call","_classCallCheck","instance","TypeError","Event","data","_ref","startAccessor","endAccessor","slotMetrics","_slotMetrics$getRange","getRange","accessor","start","startDate","end","endDate","top","height","startMs","endMs","get","rows","columns","reduce","max","row","Math","leaves","availableWidth","container","_width","noOverlap","overlap","min","index","_row","xOffset","onSameRow","a","b","abs","sortByRender","events","sortedByTime","e","sorted","event","shift","push","test","_event","splice","_ref2","proxies","map","eventsInRenderOrder","containerEvents","_loop","find","c","j","_ret","style","width"],"mappings":"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","sourcesContent":["'use strict';\n\nexports.__esModule = true;\nexports.getStyledEvents = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _sortBy = require('lodash/sortBy');\n\nvar _sortBy2 = _interopRequireDefault(_sortBy);\n\nvar _accessors = require('./accessors');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Event = function () {\n  function Event(data, _ref) {\n    var startAccessor = _ref.startAccessor,\n        endAccessor = _ref.endAccessor,\n        slotMetrics = _ref.slotMetrics;\n\n    _classCallCheck(this, Event);\n\n    var _slotMetrics$getRange = slotMetrics.getRange((0, _accessors.accessor)(data, startAccessor), (0, _accessors.accessor)(data, endAccessor)),\n        start = _slotMetrics$getRange.start,\n        startDate = _slotMetrics$getRange.startDate,\n        end = _slotMetrics$getRange.end,\n        endDate = _slotMetrics$getRange.endDate,\n        top = _slotMetrics$getRange.top,\n        height = _slotMetrics$getRange.height;\n\n    this.start = start;\n    this.end = end;\n    this.startMs = +startDate;\n    this.endMs = +endDate;\n    this.top = top;\n    this.height = height;\n    this.data = data;\n  }\n\n  /**\n   * The event's width without any overlap.\n   */\n\n\n  _createClass(Event, [{\n    key: '_width',\n    get: function get() {\n      // The container event's width is determined by the maximum number of\n      // events in any of its rows.\n      if (this.rows) {\n        var columns = this.rows.reduce(function (max, row) {\n          return Math.max(max, row.leaves.length + 1);\n        }, // add itself\n        0) + 1; // add the container\n\n        return 100 / columns;\n      }\n\n      var availableWidth = 100 - this.container._width;\n\n      // The row event's width is the space left by the container, divided\n      // among itself and its leaves.\n      if (this.leaves) {\n        return availableWidth / (this.leaves.length + 1);\n      }\n\n      // The leaf event's width is determined by its row's width\n      return this.row._width;\n    }\n\n    /**\n     * The event's calculated width, possibly with extra width added for\n     * overlapping effect.\n     */\n\n  }, {\n    key: 'width',\n    get: function get() {\n      var noOverlap = this._width;\n      var overlap = Math.min(100, this._width * 1.7);\n\n      // Containers can always grow.\n      if (this.rows) {\n        return overlap;\n      }\n\n      // Rows can grow if they have leaves.\n      if (this.leaves) {\n        return this.leaves.length > 0 ? overlap : noOverlap;\n      }\n\n      // Leaves can grow unless they're the last item in a row.\n      var leaves = this.row.leaves;\n\n      var index = leaves.indexOf(this);\n      return index === leaves.length - 1 ? noOverlap : overlap;\n    }\n  }, {\n    key: 'xOffset',\n    get: function get() {\n      // Containers have no offset.\n      if (this.rows) return 0;\n\n      // Rows always start where their container ends.\n      if (this.leaves) return this.container._width;\n\n      // Leaves are spread out evenly on the space left by its row.\n      var _row = this.row,\n          leaves = _row.leaves,\n          xOffset = _row.xOffset,\n          _width = _row._width;\n\n      var index = leaves.indexOf(this) + 1;\n      return xOffset + index * _width;\n    }\n  }]);\n\n  return Event;\n}();\n\n/**\n * Return true if event a and b is considered to be on the same row.\n */\n\n\nfunction onSameRow(a, b) {\n  return (\n    // Occupies the same start slot.\n    Math.abs(b.start - a.start) <= 30 ||\n    // A's start slot overlaps with b's end slot.\n    a.start > b.start && a.start < b.end\n  );\n}\n\nfunction sortByRender(events) {\n  var sortedByTime = (0, _sortBy2.default)(events, ['startMs', function (e) {\n    return -e.endMs;\n  }]);\n\n  var sorted = [];\n  while (sortedByTime.length > 0) {\n    var event = sortedByTime.shift();\n    sorted.push(event);\n\n    for (var i = 0; i < sortedByTime.length; i++) {\n      var test = sortedByTime[i];\n\n      // Still inside this event, look for next.\n      if (event.endMs > test.startMs) continue;\n\n      // We've found the first event of the next event group.\n      // If that event is not right next to our current event, we have to\n      // move it here.\n      if (i > 0) {\n        var _event = sortedByTime.splice(i, 1)[0];\n        sorted.push(_event);\n      }\n\n      // We've already found the next event group, so stop looking.\n      break;\n    }\n  }\n\n  return sorted;\n}\n\nfunction getStyledEvents(_ref2) {\n  var events = _ref2.events,\n      props = _objectWithoutProperties(_ref2, ['events']);\n\n  // Create proxy events and order them so that we don't have\n  // to fiddle with z-indexes.\n  var proxies = events.map(function (event) {\n    return new Event(event, props);\n  });\n  var eventsInRenderOrder = sortByRender(proxies);\n\n  // Group overlapping events, while keeping order.\n  // Every event is always one of: container, row or leaf.\n  // Containers can contain rows, and rows can contain leaves.\n  var containerEvents = [];\n\n  var _loop = function _loop(i) {\n    var event = eventsInRenderOrder[i];\n\n    // Check if this event can go into a container event.\n    var container = containerEvents.find(function (c) {\n      return c.end > event.start || Math.abs(event.start - c.start) < 30;\n    });\n\n    // Couldn't find a container — that means this event is a container.\n    if (!container) {\n      event.rows = [];\n      containerEvents.push(event);\n      return 'continue';\n    }\n\n    // Found a container for the event.\n    event.container = container;\n\n    // Check if the event can be placed in an existing row.\n    // Start looking from behind.\n    var row = null;\n    for (var j = container.rows.length - 1; !row && j >= 0; j--) {\n      if (onSameRow(container.rows[j], event)) {\n        row = container.rows[j];\n      }\n    }\n\n    if (row) {\n      // Found a row, so add it.\n      row.leaves.push(event);\n      event.row = row;\n    } else {\n      // Couldn't find a row – that means this event is a row.\n      event.leaves = [];\n      container.rows.push(event);\n    }\n  };\n\n  for (var i = 0; i < eventsInRenderOrder.length; i++) {\n    var _ret = _loop(i);\n\n    if (_ret === 'continue') continue;\n  }\n\n  // Return the original events, along with their styles.\n  return eventsInRenderOrder.map(function (event) {\n    return {\n      event: event.data,\n      style: {\n        top: event.top,\n        height: event.height,\n        width: event.width,\n        xOffset: event.xOffset\n      }\n    };\n  });\n}\n\nexports.getStyledEvents = getStyledEvents;"]},"metadata":{},"sourceType":"script"}